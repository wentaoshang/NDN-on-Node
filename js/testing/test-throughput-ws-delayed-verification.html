<?xml version = "1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"DTD/xhtml1-strict.dtd">
<html xmlns = "http://www.w3.org/1999/xhtml">
<meta charset="UTF-8">

<head>
	<title>NDN Fetch File via WebSocket using Group Verification</title>
	
	<script type="text/javascript" src="../tools/build/ndn-js-uncomp.js"></script>

	<script type="text/javascript">
		var hostip = "131.179.196.232";
		//var hostip = "localhost";
		//var ndncon = new NDN({port:9696,host:hostip});
		var ndncon = new NDN({port:9696,host:hostip,verify:false});
        ndncon.transport.connectWebSocket(ndncon);
        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
        var MerkleHashNode = function MerkleHashNode(hash, index) {
        	this.hash = hash;
        	this.index = index;
        };
        
        /*
		 * Closure for calling expressInterest to fetch big file.
		 */                                                
		var ContentClosure = function ContentClosure(ndn, T0) {
		    // Inherit from Closure.
		    Closure.call(this);
		    
		    this.T0 = T0;
		    this.ndn = ndn;
			this.totalBlocks = 0;
		    
		    this.firstReceivedSegmentNumber = null;
		    this.firstReceivedContentObject = null;
		    
		    this.merkleHashTree = [];
		    this.rsaKey = decodeSubjectPublicKeyInfo(DataUtils.toNumbers(
		    	"30819F300D06092A864886F70D010101050003818D0030818902818100B3E4FE19516EACD661816D170B4287FE2713CFD30833D64C8DE59D68A7E2EE88B33172E6B18C185BB2B75805A755992A04CE0CD9E670CB6FF2D41D83ACB7A9EEE211920704AB26201343AD7661C0D6D5F4B5CCB6DA0BCDB39982C2B1899E8FBB434A4F936A2A6351CC5C26648A39803B04049B06EC0498FC0587922A7518933F0203010001"
		    ));
		};
		
		ContentClosure.prototype.verifySegments = function(key, sig, lastIndex) {
			var i = lastIndex - 1;
			while (i > 0) {
		    	var str = this.merkleHashTree[i - 1].hash + this.merkleHashTree[i].hash;
		    	var hash = hex_sha256_from_bytes(DataUtils.toNumbers(str));
		    	var node = new MerkleHashNode(hash, Math.floor(i / 2));
		    	// Remove the curent two nodes and put their parent node into the array on their position
		    	this.merkleHashTree[node.index - 1] = node;
		    	i = i - 2;
	    	}
	    	
	    	var root = this.merkleHashTree[0];
	    	this.merkleHashTree = [];
	    	
	    	return key.verifyByteArray(DataUtils.toNumbers(root.hash), null, sig);
	    };
		
		ContentClosure.prototype.upcall = function(kind, upcallInfo) {
		    if (kind == Closure.UPCALL_INTEREST_TIMED_OUT) {
		    	var T1 = new Date();
		    	document.getElementById('content').innerHTML += "<p>Interest time out.</p>";
		        document.getElementById('content').innerHTML += "<p>Time elapsed: " + (T1 - this.T0) + " ms including 4s timeout</p>";
		        document.getElementById('content').innerHTML += "<p>Total number of blocks: " + this.totalBlocks + "</p>";
		        return Closure.RESULT_OK;
		    }
		    
		    if (kind == Closure.UPCALL_CONTENT_BAD) {
		    	console.log("NdnProtocol.ContentClosure: signature verification failed");
		    	console.log(upcallInfo.contentObject.name.getName());
		    	console.log(DataUtils.toHex(upcallInfo.contentObject.signature.Witness).toLowerCase());
		    	return Closure.RESULT_OK;
		    }
		    
		    if (!(kind == Closure.UPCALL_CONTENT ||
		          kind == Closure.UPCALL_CONTENT_UNVERIFIED))
		        // The upcall is not for us.
		        return Closure.RESULT_ERR;
		    
		    var contentObject = upcallInfo.contentObject;
		    if (contentObject.content == null) {
		        console.log("NdnProtocol.ContentClosure: contentObject.content is null");
		        return Closure.RESULT_ERR;
		    }
		
		    // Use the segmentNumber to load multiple segments.
		    //var segmentNumber = ArrayToNum(contentObject.name.components[contentObject.name.components.length - 1]);
		    var segmentNumber = DataUtils.bigEndianToUnsignedInt
		    						(contentObject.name.components[contentObject.name.components.length - 1]);
		    //console.log(segmentNumber);
		    
		    /* XXX: we assume the first segment is always #0
	        if (this.firstReceivedSegmentNumber == null) {
	            // This is the first call.
	            this.firstReceivedSegmentNumber = segmentNumber;
	            if (segmentNumber != 0) {
	                // Special case: Save this content object for later and request segment zero.
	                this.firstReceivedContentObject = contentObject;
	                var componentsForZero = contentObject.name.components.slice
	                    (0, contentObject.name.components.length - 1);
	                componentsForZero.push([0]);
	                this.ndn.expressInterest(new Name(componentsForZero), this);
	                return Closure.RESULT_OK;
	            }
	        }
	        */
		    
		    // Process received data here...
		    // Count content length
		    //nameStr = escape(contentObject.name.getName());
			//document.getElementById('content').innerHTML += "<p>Name string: " + nameStr + "</p>";
			//document.getElementById('content').innerHTML += "<p>Content buffer length: " + contentObject.content.length + "</p>";
			this.totalBlocks++;
		    
		    /* XXX: we assume the first segment is always #0
		    // Check for the special case if the saved content is for the next segment that we need.
		    if (this.firstReceivedContentObject != null && 
		        this.firstReceivedSegmentNumber == segmentNumber + 1) {
		        // Substitute the saved contentObject send its content and keep going.
		        contentObject = this.firstReceivedContentObject;
		        segmentNumber = segmentNumber + 1;
		        // Clear firstReceivedContentObject to save memory.
		        this.firstReceivedContentObject = null;
		        
		        // Process received data here...
		    	// Count content length
		    	//nameStr = escape(contentObject.name.getName());
				//document.getElementById('content').innerHTML += "<p>Name string: " + nameStr + "</p>";
				//document.getElementById('content').innerHTML += "<p>Content buffer length: " + contentObject.content.length + "</p>";
				this.totalBlocks++;
		    }
		    */
		    
		    // Create Merkle hash node for this segment
		    var wit = new Witness();
			wit.decode(contentObject.signature.Witness);
			var hash = hex_sha256_from_bytes(contentObject.rawSignatureData);
		    var node = new MerkleHashNode(hash, wit.path.index);
		    //console.log(node.index);
		    this.merkleHashTree[node.index - 1] = node;
		    
		    var sigHex = DataUtils.toHex(contentObject.signature.signature).toLowerCase();
		
		    var finalSegmentNumber = null;
		    if (contentObject.signedInfo != null && contentObject.signedInfo.finalBlockID != null)
		        finalSegmentNumber = DataUtils.bigEndianToUnsignedInt(contentObject.signedInfo.finalBlockID);
		    
		    if (finalSegmentNumber == null || segmentNumber != finalSegmentNumber) {
		    	// If we received a full group of 128 segments, verify now
		    	if (wit.path.index == 255) {
		    		var ret = this.verifySegments(this.rsaKey, sigHex, wit.path.index);
		    		if (ret == false) {
		    			// Failed to verify this group of segments, we can abort fetching now
		    			console.log(wit);
		    			console.log("Group signature verification failed on segment " + segmentNumber);
		    			return Closure.RESULT_OK;
		    		}
		    	}
		    	
		    	// Fetch the next segment
		    	
		        // Make a name for the next segment and get it.
		        var segmentNumberPlus1 = DataUtils.nonNegativeIntToBigEndian(segmentNumber + 1);
		        // Put a 0 byte in front.
		        var nextSegmentNumber = new Uint8Array(segmentNumberPlus1.length + 1);
		        nextSegmentNumber.set(segmentNumberPlus1, 1);
        		
		        var components = contentObject.name.components.slice
		            (0, contentObject.name.components.length - 1);
		        components.push(nextSegmentNumber);
		        //components.push(segmentNumberPlus1);
		        this.ndn.expressInterest(new Name(components), this);
		    }
		    else {
		        // Final block received.
	    		var ret = this.verifySegments(this.rsaKey, sigHex, wit.path.index);
	    		if (ret == false) {
	    			// Failed to verify this group of segments, we can abort fetching now
	    			console.log("NdnProtocol.ContentClosure: last group signature verification failed");
	    			return Closure.RESULT_OK;
	    		}
		    	
		    	//console.log("Group signature verification success");
		    	
		        // Content segments verified.
		        // Record stop time
		        var T1 = new Date();
		        document.getElementById('content').innerHTML += "<p>Final block received.</p>";
		        document.getElementById('content').innerHTML += "<p>Time elapsed: " + (T1 - this.T0) + " ms</p>";
		        document.getElementById('content').innerHTML += "<p>Total number of blocks: " + this.totalBlocks + "</p>";
		    }
		        
		    return Closure.RESULT_OK;
		};
		
///////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		function run() {
			document.getElementById('content').innerHTML += "<p>Started...</p>";
			
			var name = new Name(document.getElementById('interest').value);
            ndncon.expressInterest( name, 
                    new ContentClosure( ndncon, new Date() ));
		}
		
	</script>
	
</head>
<body >

	<form>
		Please Enter an Interest:<br />
		<input id="interest" type="text" name="INTEREST" size="50" value="/wentao.shang/oreshura.jpg/%00" /> 
	</form>

	<button onclick="run()">Fetch Content</button>
	
	<p id="content">Result: <br/></p>

</body>
</html>
